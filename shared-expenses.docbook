<?xml version="1.0" encoding="UTF-8"?>
<article xmlns="http://docbook.org/ns/docbook"
	 xmlns:xl="http://www.w3.org/1999/xlink"
	 version="5.0">
  <title>Shared Expenses, a Prolog Solver</title>
  <para>In a shared living situation, it can be hard to keep track of who owes money to whom. A major complicating factor is that one roommate may reimburse another for some expense, and that money has to be taken into account.</para>
  
  <para>I saw <link xl:href="http://lpenz.github.com/articles/hedsl-sharedexpenses/index.html">an article about this problem</link> a while back.</para>

  <para>Let's examine a Prolog solution.</para>

  <para>First, let's define some operators so we can make this into a <acronym>DSL</acronym> or domain-specific language.</para>

  <programlisting role="source">
    :- op(400, xfx, spent).
    :- op(400, xfy, gave).
    :- op(400, xfy, gives).
    :- op(300, xfx, to).
    :- op(400, xfx, owes).
    :- op(400, xfx, is_owed).
  </programlisting>

  <para>By supplying these definitions, Prolog can now be used to represent the data directly:</para>

  <programlisting>
    ?- X = dexter spent 5300.
    true.

    ?- X = dexter gave 2000 to harry.
    true.
  </programlisting>

  <para>Let's bring over the sample database so we can compare it's aesthetics:</para>

  <programlisting role="source">
    dexter spent 5300.
    angel spent 2700.
    debra spent 800.
    harry spent 1900.
    debra spent 1700.
    angel spent 2200.

    dexter gave 2000 to harry.
    angel gave 3200 to debra.
  </programlisting>

  <para>Building on this, let's figure out what everybody's personal expenditures are, not taking into account "gifts" just yet.</para>

  <programlisting role="source">
    total_spent(Person, Total) :-
      bagof(Amount, Person spent Amount, Receipts),
      sum(Receipts, Total).
  </programlisting>

  <para>Unfortunately, the predicate <code>total_spent/2</code> references <code>sum/2</code>, which isn't in the standard library, but should be. We can add our own implementation:</para>

  <programlisting role="source">
    sum(List, Total) :- sum(List, 0, Total).

    sum([], Total, Total).
    sum([X|Xs], Acc, Total) :- Acc1 is Acc + X, sum(Xs, Acc1, Total).
  </programlisting>

  <para>We can now see that <code>total_spent/2</code> is going to generate all the people and the total they've spent:</para>

  <screen>
    ?- total_spent(Person, Total).
    Person = angel,
    Total = 4900 ;

    Person = debra,
    Total = 2500 ;

    Person = dexter,
    Total = 5300 ;

    Person = harry,
    Total = 1900.
  </screen>

  <para>We can calculate the total outlay on top of this or on top of the raw <code>spent</code> facts; either way, it doesn't affect the outcome.</para>

  <programlisting role="source">
    total_outlay(Total) :-
      findall(Amount, _ spent Amount, Expenditures),
      sum(Expenditures, Total).
  </programlisting>

  <screen>
    ?- total_outlay(X).
    X = 14600.
  </screen>

  <para>We can calculate the per-person expected contribution by dividing the total outlay by the number of people:</para>

  <programlisting role="source">
    expected_contribution(X) :-
      total_outlay(Total),
      setof(Person, A^(Person spent A), People),
      length(People, RoommateCount),
      X is Total / RoommateCount.
  </programlisting>

  <screen>
    ?- expected_contribution(X).
    X = 3650.
  </screen>

  <para>So, we've already calculated what everybody should have contributed and what everybody has already spent. Now we simply need to account for individual donations and then we can output who should pay what to whom.</para>

  <para>There are two ways forward from here. Let's examine them both. The first one is to use the database to store what we calculate. We could <code>asserta(owes(Person, ExpectedContribution))</code> and then have one process to update that value, first with what they've spent, then with the result of applying their donations. A part of me balks at this because it means storing intermediate results in the fact database, which is not susceptible to backtracking and can therefore introduce errors in a way that our raw data cannot.</para>

  <para>Another approach would be to have a resolution process that pulls all the relevant data from the database and passes it along in lists recursively until all the outstanding transactions have been handled, and then forwards its final state to a process that displays the outcome. This strikes me as a cleaner approach, even though it necessitates using a list as a map (since Prolog doesn't really have a map datastructure).</para>

  <para>Odds are good if you're new to Prolog and come from a procedural background, the first solution will sound better to you. If you come from a functional background the second solution will probably sound better to you. Let's make them both and see which one is nicer.</para>

  <programlisting role="source">
    reconcile(Reconciliation) :-
      findall(X spent Amt, total_spent(X, Amt), Expenditures),
      findall(X gave Y to Z, X gave Y to Z, Donations),
      reconcile_all(Donations, Expenditures, Reconciliation).

    reconcile_all([], Reconciliation, Reconciliation).
    reconcile_all([Donation|Donations], Expenditures, Reconciliation) :-
      reconcile(Donation, Expenditures, NewExpenditures),
      reconcile_all(Donations, NewExpenditures, Reconciliation).
    
    reconcile(Donor gave Amt to Recipient,
              PreviousExpenditures,
              [Donor spent DonorAfter, Recipient spent RecipientAfter | OldExpenditures1]) :-
      select(Donor spent DonorBefore, PreviousExpenditures, OldExpenditures0),
      select(Recipient spent RecipientBefore, OldExpenditures0, OldExpenditures1),
      DonorAfter is DonorBefore + Amt,
      RecipientAfter is RecipientBefore - Amt.

    balances([], []).
    balances([_ spent Baseline|Roommates], Debts) :-
      expected_contribution(Baseline),
      balances(Roommates, Debts).
    balances([Roommate spent Expenditure|Roommates], [Roommate owes Amount|Debts]) :-
      expected_contribution(Baseline),
      Baseline > Expenditure,
      Amount is Baseline - Expenditure,
      balances(Roommates, Debts).      
    balances([Roommate spent Expenditure|Roommates], [Roommate is_owed Amount|Debts]) :-
      expected_contribution(Baseline),
      Expenditure > Baseline,
      Amount is Expenditure - Baseline,
      balances(Roommates, Debts).

    suggestions([], []).
    suggestions(Situation, [Donor gives Amount to Recipient|Suggestions]) :-
      select(Donor owes Amount, Situation, OldSituation0),
      select(Recipient is_owed Amount, OldSituation0, OldSituation1),
      write(Donor gives Amount to Recipient), nl,
      suggestions(OldSituation1, Suggestions).
    suggestions(Situation, [Donor gives Credit to Recipient|Suggestions]) :-
      select(Donor owes Debt, Situation, OldSituation0),
      select(Recipient is_owed Credit, OldSituation0, OldSituation1),
      Debt > Credit,
      NewDebt is Debt - Credit,
      write(Donor gives Credit to Recipient), nl,
      suggestions([Donor owes NewDebt|OldSituation1], Suggestions).
    suggestions(Situation, [Donor gives Debt to Recipient|Suggestions]) :-
      select(Donor owes Debt, Situation, OldSituation0),
      select(Recipient is_owed Credit, OldSituation0, OldSituation1),
      Credit > Debt,
      NewCredit is Credit - Debt,
      write(Donor gives Debt to Recipient), nl,
      suggestions([Recipient is_owed NewCredit|OldSituation1], Suggestions).
  </programlisting>
    
</article>
